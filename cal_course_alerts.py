# -*- coding: utf-8 -*-
"""Cal_Course_Alerts.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D0LyFPxi24np4mjZlkrcoHIskWAb8kQP
"""

#!/usr/local/bin/python3

"""# Cal Course Alerts

Given email and list of course IDs, an email might be sent if any spot is available

## Collector

Using http.client lib, connect to classes.berkeley.edu, get list of json string
"""

import http.client

def collect(url):
  ''' Connect to data source, fetch data based on URL
  >>> collect("/enrollment/update/2188/xyz")
  '"false"'
  >>> "changed" in collect("/enrollment/update/2188/23404")
  True
  >>> "available" in collect("/enrollment/update/2188/23430")
  True
  '''
  HOST = "classes.berkeley.edu"
  conn = http.client.HTTPSConnection(HOST)
  conn.request("GET", url)
  request = conn.getresponse()
  return request.read().decode()

"""##Extractor

From JSON string returned, find
- Status
- Available seats
- Avaliable waitlist
- Reseved seats
"""

import json

def extract(string):
  ''' Extract data points from JSON string
  >>> extract(collect('/enrollment/update/2188/31404'))
  ('Open', 0, 0, ['  - reserve: 86/90, open: 4 for Psychology Majors'])
  '''
  def reservation(key, stat):
    TEMPLATE = "  - reserve: {}/{}, open: {} for {}"
    if key in stat:
      for seat in stat[key]:
        lim = seat["maxEnroll"]
        cnt = seat["enrolledCount"]
        if lim > cnt:
          yield TEMPLATE.format(cnt, lim, lim - cnt,
            seat["requirementGroup"]["description"])

  data = json.loads(string)
  relevant = data["available"]["enrollmentStatus"]

  status = relevant["status"]["description"]
  seats = relevant["maxEnroll"] - relevant["enrolledCount"] - relevant["openReserved"]
  waitlist = relevant["maxWaitlist"] - relevant["waitlistedCount"]
  reserved = reservation("seatReservations", relevant)

  return (status, seats, waitlist, list(reserved))

"""From JSON string out of div tag, find
- course ID
- course name
- course serial number
- course description
"""

from html.parser import HTMLParser
import json

class CourseParser(HTMLParser):
  def __init__(self):
    super().__init__()
    self.info = None

  def handle_starttag(self, tag, attrs):
    if tag == 'div':
      attr = dict(attrs)
      if attr['class'] == 'handlebarData theme_is_cc_berkeley':
        summary = json.loads(attr['data-json'])
        course = summary['class']['course']
        self.info = (summary['id'], course['displayName'], summary['number'], course['title'])

  def get_course_info(self):
    return self.info


def get_name(subject, number):
  ''' Get list of (id, description) from subject-number
  >>> get_name("compsci", 188)
  [(27019, 'COMPSCI 188 - Introduction to Artificial Intelligence')]
  >>> get_name("compsci", 160)
  [(27144, 'COMPSCI 160-001 - User Interface Design and Development'), (30997, 'COMPSCI 160-002 - User Interface Design and Development'), (30998, 'COMPSCI 160-003 - User Interface Design and Development')]
  '''
  def get_list(subject, number):
    TEMPLATE = "/content/2018-fall-{0}-{1}-{2:0>3}-lec-{2:0>3}"
    for sec in range(1, 4):
      url = TEMPLATE.format(subject, number, sec)
      data = collect(url)
      parser = CourseParser()
      parser.feed(data)
      yield parser.get_course_info()
      
  course_list = [item for item in get_list(subject, number) if item is not None]
  if len(course_list) == 1:
    item = course_list[0]
    return [(item[0], "{} - {}".format(item[1], item[3]))]
  else:
    return [(item[0], "{}-{} - {}".format(item[1], item[2], item[3])) for item in course_list]

"""##Analyzer

From the info above, apply logic, form message
"""

TEMPLATE = "\n{}\n  There are {} seats remaining {}\n"

def analyze(identifier, status, seats, waitlist, reserved):
  ''' Compose message from data
  >>> analyze(31404, 'Open', 0, 0, [])
  ''
  >>> analyze("12345", "Open", 1, 1, [])
  '\\n12345\\n  There are 1 seats remaining in the class\\n'
  >>> analyze("12345", "Open", 0, 1, ['  - reserve: 86/90, open: 4 for Psychology Majors'])
  '\\n12345\\n  There are 1 seats remaining on the waitlist\\n  - reserve: 86/90, open: 4 for Psychology Majors\\n'
  '''
  def format_text(title, number, category, reserved):
    reservation = '\n'.join(reserved)
    if len(reservation) > 0:
      reservation += '\n'
    return TEMPLATE.format(title, number, category) + reservation

  if seats > 0:
    return format_text(identifier, seats, "in the class", reserved)
  elif waitlist > 0:
    return format_text(identifier, waitlist, "on the waitlist", reserved)
  else:
    return ""

"""##Notifier

Notify by email
"""

def notify(email, subj, body):
  ''' conditionally send email, if
      - there is a content for message
      - the message is different from previous one
  >>> from unittest.mock import Mock
  >>> sendemail = Mock()
  >>> notify("is.testingscripts@gmail.com", "foo", "bar")
  >>> sendemail.assert_not_called()
  >>> #sendemail.assert_called_with("is.testingscripts@gmail.com", "foo", "bar")
  >>> fh = open("previousEmail", "w+") # clean up the file
  >>> fh.read()
  ''
  '''
  try:
    with open("previousEmail", "r") as file:
      read_data = file.read()
  except FileNotFoundError as err:
    read_data = ""

  with open("previousEmail", "w") as file:
    file.write(body)

  if len(body) > 0 and body != read_data:
    sendemail(email, subj, body)

"""utility to send email"""

import smtplib

def sendemail(address, subject, body,
              login='is.testingscripts@gmail.com',
              password='Lower05!',
              server=smtplib.SMTP('smtp.gmail.com:587')):
    ''' wrapper SMTP lib
    >>> from unittest.mock import Mock
    >>> login = 'is.testingscripts@gmail.com'
    >>> (email, head, body) = ("xyz@abc.com", 'foo', 'bar')
    >>> TEMP = 'From: {}\\nTo: {}\\nSubject: {}\\n\\n{}'
    >>> message = TEMP.format(login, email, head, body)
    >>> server = smtplib.SMTP('smtp.gmail.com:587')
    >>> server.starttls = Mock()
    >>> server.login = Mock()
    >>> server.sendmail = Mock()
    >>> server.quit = Mock()
    >>> sendemail(email, head, body, server=server)
    >>> server.starttls.assert_called_once()
    >>> server.login.assert_called_once_with(login, 'Lower05!')
    >>> server.sendmail.assert_called_once_with(login, email, message)
    >>> server.quit.assert_called_once()
    '''
    header  = 'From: %s\n' % login
    header += 'To: %s\n' % address
    header += 'Subject: %s\n\n' % subject

    server.starttls()
    server.login(login, password)
    server.sendmail(login, address, header + body)
    server.quit()

"""## Alerter

Put all together, send email based on list of courses
"""

def alert(email, courses):
  ''' Generate message base on course list
  >>> len(list(gen_msg("compsci-188,anthro-107")))
  2
  '''
  def gen_msg(courses):
    for course in courses.split(","):
      (subject, number) = course.split("-")
      for (identifer, description) in get_name(subject, number):
        json_data = collect("/enrollment/update/2188/{}".format(identifer))
        info = extract(json_data)
        yield analyze(description, *info)

  intel = "".join(gen_msg(courses))
  notify(email, "Alerts for courses: " + courses, intel)

"""Run Doc test"""

if __name__ == '__main__':
  import doctest
  doctest.testmod()